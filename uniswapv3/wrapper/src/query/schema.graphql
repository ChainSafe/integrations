#import { Query, StaticTxResult } into Ethereum from "w3://ens/ethereum.web3api.eth"
#import { Query } into SHA3 from "w3://ens/sha3.web3api.eth"
#import { Query } into ERC20 from "w3://ipfs/QmeiPWHe2ixfitcgjRwP5AaJD5R7DbsGhQNQwT4rFNyxx8"
#import { ChainId, TradeType, Currency, Token, Price, TokenAmount, Tick, TickListDataProvider, Pool, FeeAmount, Route, TradeSwap, Trade, BestTradeOptions, Position, PermitOptions, FeeOptions, SwapOptions, MethodParameters, GasOptions, MintAmounts } from "../common/schema.graphql"

#ximport { Query } into Console from "w3://ipfs/QmVGwj3FtvhiErJ1wWbmRuHpvEQ3t1BPNESvEiMJM57p2y"

enum Rounding {
  ROUND_DOWN
  ROUND_HALF_UP
  ROUND_UP
}

# Return value of nextInitializedTickWithinOneWord(...)
type NextTickResult {
  index: Int32!
  found: Boolean!
}

# Input or output amount and next pool state; return value of getPoolInputAmount(...) and getPoolOutputAmount(...)
type PoolChangeResult {
  amount: TokenAmount!
  nextPool: Pool!
}

# Input used to create a trade
type TradeRoute {
  route: Route! # The route of the trade
  amount: TokenAmount! # The amount being passed in or out, depending on the trade type
}

# Represents a unique staking program.
type IncentiveKey {
  rewardToken: Token! # The token rewarded for participating in the staking program.
  pool: Pool! # The pool that the staked positions must provide in.
  startTime: BigInt! # The time when the incentive program begins.
  endTime: BigInt! # The time that the incentive program ends.
  refundee: String! #  The address which receives any remaining reward tokens at `endTime`.
}

# Options to specify when claiming rewards.
type ClaimOptions {
  tokenId: BigInt! # The id of the NFT
  recipient: String! # Address to send rewards to.
  amount: BigInt # The amount of `rewardToken` to claim. 0 claims all.
}

type FullWithdrawOptions implements ClaimOptions {
  owner: String! # Set when withdrawing. The position will be sent to `owner` on withdraw.
  data: String #  Set when withdrawing. `data` is passed to `safeTransferFrom` when transferring the position from contract back to owner.
}

# Optional arguments to send to the quoter.
type QuoteOptions {
  sqrtPriceLimitX96: BigInt # The optional price limit for the trade.
}

# Options for producing the calldata to add liquidity.
type CommonAddLiquidityOptions {
  slippageTolerance: String! # How much the pool price is allowed to move.
  deadline: BigInt! # When the transaction expires, in epoch seconds.
  useNative: Token # Whether to spend ether. If true, one of the pool tokens must be WETH, by default false
  token0Permit: PermitOptions # The optional permit parameters for spending token0
  token1Permit: PermitOptions # The optional permit parameters for spending token1
}

#type MintOptions implements CommonAddLiquidityOptions {
#  recipient: String! # The account that should receive the minted NFT.
#  createPool: Boolean # Creates pool if not initialized before mint.
#}
#
#type IncreaseOptions implements CommonAddLiquidityOptions {
#  tokenId: BigInt! # Indicates the ID of the position to increase liquidity for.
#}
#
#union AddLiquidityOptions = MintOptions | IncreaseOptions
# TODO: Return to use of union type once union type support is merged
type AddLiquidityOptions implements CommonAddLiquidityOptions {
  recipient: String # The account that should receive the minted NFT.
  createPool: Boolean # Creates pool if not initialized before mint.
  tokenId: BigInt # Indicates the ID of the position to increase liquidity for.
}

type SafeTransferOptions {
  sender: String! # The account sending the NFT.
  recipient: String! # The account that should receive the NFT.
  tokenId: BigInt! # The id of the token being sent.
  data: String # The optional parameter that passes data to the `onERC721Received` call for the staker
}

type CollectOptions {
  tokenId: BigInt! # Indicates the ID of the position to collect for.
  expectedCurrencyOwed0: TokenAmount! # Expected value of tokensOwed0, including as-of-yet-unaccounted-for fees/liquidity value to be burned
  expectedCurrencyOwed1: TokenAmount! # Expected value of tokensOwed1, including as-of-yet-unaccounted-for fees/liquidity value to be burned
  recipient: String! # The account that should receive the tokens.
}

type NFTPermitOptions {
  v: PermitV!
  r: String!
  s: String!
  deadline: BigInt!
  spender: String!
}

# Options for producing the calldata to exit a position.
type RemoveLiquidityOptions {
  tokenId: BigInt! # The ID of the token to exit
  liquidityPercentage: String! # The percentage of position liquidity to exit.
  slippageTolerance: String! # How much the pool price is allowed to move.
  deadline: BigInt! # When the transaction expires, in epoch seconds.
  burnToken: Boolean # Whether the NFT should be burned if the entire position is being exited, by default false.
  permit: NFTPermitOptions # The optional permit of the token ID being exited, in case the exit transaction is being sent by an account that does not own the NFT
  collectOptions: CollectOptions! # Parameters to be passed on to collect
}

type Query {

  ## Token

  currencyEquals(
    currencyA: Currency!
    currencyB: Currency!
  ): Boolean!

  tokenEquals(
    tokenA: Token!
    tokenB: Token!
  ): Boolean!

  tokenAmountEquals(
    tokenAmountA: TokenAmount!
    tokenAmountB: TokenAmount!
  ): Boolean!

  tokenSortsBefore(
    tokenA: Token!
    tokenB: Token!
  ): Boolean!

  ## Token Utils

  getEther(
    chainId: ChainId!
  ): Token!

  getWETH(
    chainId: ChainId!
  ): Token!

  isEther(
    token: Token!
  ): Boolean!

  wrapToken(
    token: Token!
  ): Token!

  wrapAmount(
    amount: TokenAmount!
  ): TokenAmount!

  ## TickDataProvider

  # constructs and validates a TickListDataProvider
  createTickListDataProvider(
    ticks: [Tick!]!
    tickSpacing: Int32!
  ): TickListDataProvider!

  # returns tick at requested index
  getTick(
    tickDataProvider: TickListDataProvider!
    tickIndex: Int32!
  ): Tick!

  # returns next initialized tick, or max or min tick. Returns true if a tick is found at index
  nextInitializedTickWithinOneWord(
    tickDataProvider: TickListDataProvider!
    tick: Int32!
    lte: Boolean!
    tickSpacing: Int32!
  ): NextTickResult!

  ## Pool

  # constructs and validates a Pool
  createPool(
    tokenA: Token!
    tokenB: Token!
    fee: FeeAmount!
    sqrtRatioX96: BigInt!
    liquidity: BigInt!
    tickCurrent: Int32!
    ticks: TickListDataProvider
  ): Pool!

  # Returns the Ethereum address of the Pool contract
  getPoolAddress(
    tokenA: Token! # The first token of the pool, irrespective of sort order
    tokenB: Token! # The second token of the pool, irrespective of sort order
    fee: FeeAmount! # The fee tier of the pool
    initCodeHashManualOverride: String # Override the init code hash used to compute the pool address if necessary
  ): String!

  # Returns true if the token is either token0 or token1
  poolInvolvesToken(
    pool: Pool!
    token: Token! # The token to check
  ): Boolean!

  # Returns the current mid price of the pool in terms of token0, i.e. the ratio of token1 over token0
  poolToken0Price(
    pool: Pool!
  ): Price!

  # Returns the current mid price of the pool in terms of token1, i.e. the ratio of token0 over token1
  poolToken1Price(
    pool: Pool!
  ): Price!

  # Returns the price of the given token in terms of the other token in the pool
  poolPriceOf(
    pool: Pool!
    token: Token! # The token to return price of
  ): Price!

  # Returns the chain ID of the tokens in the pool
  poolChainId(
    pool: Pool!
  ): ChainId!

  # Given an input amount of a token, return the computed output amount, and a pool with state updated after the trade
  getPoolOutputAmount(
    pool: Pool!
    inputAmount: TokenAmount! # The input amount for which to quote the output amount
    sqrtPriceLimitX96: BigInt # The Q64.96 sqrt price limit
  ): PoolChangeResult!

  # Given a desired output amount of a token, return the computed input amount and a pool with state updated after the trade
  getPoolInputAmount(
    pool: Pool!
    outputAmount: TokenAmount! # The output amount for which to quote the input amount
    sqrtPriceLimitX96: BigInt # The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap.
  ): PoolChangeResult!

  # Returns the tick spacing of ticks in the pool
  getPoolTickSpacing(
    pool: Pool!
  ): Int32!

   ## Route

  # Constructs and validates a Route
  createRoute(
    pools: [Pool!]! # the ordered list of pools from which to construct the route
    inToken: Token! # the input token
    outToken: Token! # the output token
  ): Route!

  # Returns the chain id of the tokens in the route
  routeChainId(
    route: Route!
  ): ChainId!

  #  Returns the mid price of the route
  routeMidPrice(
    route: Route!
  ): Price!

   ## Trade

  # Constructs an exact in trade with the given amount in and route
  createTradeExactIn(
    tradeRoute: TradeRoute! # the route of the exact in trade and the amount being passed in
  ): Trade!

  # Constructs an exact out trade with the given amount out and route
  createTradeExactOut(
    tradeRoute: TradeRoute! # the route of the exact out trade and the amount returned
  ): Trade!

  # Constructs a trade by simulating swaps through the given route
  createTradeFromRoute(
    tradeRoute: TradeRoute!  # the route to swap through and the amount specified, either input or output, depending on the trade type
    tradeType: TradeType! # whether the trade is an exact input or exact output swap
  ): Trade!

  # Constructs a trade by simulating swaps through the given routes
  createTradeFromRoutes(
    tradeRoutes: [TradeRoute!]! # the routes to swap through and how much of the amount should be routed through each
    tradeType: TradeType! # whether the trade is an exact input or exact output swap
  ): Trade!

  # Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade elsewhere and do not have any tick data
  createUncheckedTrade(
    swap: TradeSwap! # the route to swap through, the amount being passed in, and the amount returned when the trade is executed
    tradeType: TradeType! # the type of the trade, either exact in or exact out
  ): Trade!

  # Creates a trade without computing the result of swapping through the routes. Useful when you have simulated the trade elsewhere and do not have any tick data
  createUncheckedTradeWithMultipleRoutes(
    swaps: [TradeSwap!]! # the routes to swap through, the amounts being passed in, and the amounts returned when the trade is executed
    tradeType: TradeType! # the type of the trade, either exact in or exact out
  ): Trade!

  # The input amount for the trade assuming no slippage
  tradeInputAmount(
    swaps: [TradeSwap!]! # the routes to swap through, the amounts being passed in, and the amounts returned when the trade is executed
  ): TokenAmount!

  # The output amount for the trade assuming no slippage
  tradeOutputAmount(
    swaps: [TradeSwap!]! # the routes to swap through, the amounts being passed in, and the amounts returned when the trade is executed
  ): TokenAmount!

  # The price expressed in terms of output amount/input amount
  tradeExecutionPrice(
    inputAmount: TokenAmount! # the trade input amount, e.g. from Trade object or tradeInputAmount(...)
    outputAmount: TokenAmount! # the trade output amount, e.g. from Trade object or tradeOutputAmount(...)
  ): Price!

  # Returns the percent difference between the route's mid price and the price impact
  tradePriceImpact(
    swaps: [TradeSwap!]! # the routes to swap through, the amounts being passed in, and the amounts returned when the trade is executed
    outputAmount: TokenAmount! # the trade output amount, e.g. from Trade object or tradeOutputAmount(...)
  ): String!

  # Get the minimum amount that must be received from the trade for the given slippage tolerance
  tradeMinimumAmountOut(
    slippageTolerance: String! # The tolerance of unfavorable slippage from the execution price of this trade; a decimal number between 0 and 1 (e.g. "0.03") that represents a percentage
    amountOut: TokenAmount! # The output amount of the trade, before slippage, e.g. from Trade object or tradeOutputAmount(...)
    tradeType: TradeType! # The type of the trade, either exact in or exact out
  ): TokenAmount!

  # Get the maximum amount in that can be spent via the trade for the given slippage tolerance
  tradeMaximumAmountIn(
    slippageTolerance: String! # The tolerance of unfavorable slippage from the execution price of this trade; a decimal number between 0 and 1 (e.g. "0.03") that represents a percentage
    amountIn: TokenAmount! # The input amount of the trade, before slippage, e.g. from Trade object or tradeInputAmount(...)
    tradeType: TradeType! # The type of the trade, either exact in or exact out
  ): TokenAmount!

  # Return the execution price after accounting for slippage tolerance
  tradeWorstExecutionPrice(
    trade: Trade!
    slippageTolerance: String! # the allowed tolerated slippage
  ): Price!

  """
  Given a list of pools, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token
  amount to an output token, making at most `maxHops` hops.
  Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting
  the amount in among multiple routes.
  """
  bestTradeExactIn(
    pools: [Pool!]! # the pools to consider in finding the best trade
    amountIn: TokenAmount! # exact amount of input currency to spend
    tokenOut: Token! # the desired currency out
    options: BestTradeOptions # options used when determining the best trade
  ): [Trade!]!

  """
  similar to bestTradeExactIn(...) but instead targets a fixed output amount
  given a list of pools, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token
  to an output token amount, making at most `maxHops` hops
  note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting
  the amount in among multiple routes.
  """
  bestTradeExactOut(
    pools: [Pool!]! # the pools to consider in finding the best trade
    tokenIn: Token! # the currency to spend
    amountOut: TokenAmount! # the desired currency amount out
    options: BestTradeOptions # options used when determining the best trade
  ): [Trade!]!

   ## Position

  # Constructs and validates a Position for a given Pool with the given liquidity
  createPosition(
    pool: Pool! # For which pool the liquidity is assigned
    tickLower: Int32! # The lower tick of the position
    tickUpper: Int32! # The upper tick of the position
    liquidity: BigInt! # The amount of liquidity that is in the position
  ): Position!

  # Computes the maximum amount of liquidity received for a given amount of token0, token1, and the prices at the tick boundaries
  createPositionFromAmounts(
    pool: Pool! # The pool for which the position should be created
    tickLower: Int32! # The lower tick of the position
    tickUpper: Int32! # The upper tick of the position
    amount0: BigInt! # token0 amount
    amount1: BigInt! # token1 amount
    useFullPrecision: Boolean! # If false, liquidity will be maximized according to what the router can calculate, not what core can theoretically support
  ): Position!

  # Computes a position with the maximum amount of liquidity received for a given amount of token0, assuming an unlimited amount of token1
  createPositionFromAmount0(
    pool: Pool! # The pool for which the position should be created
    tickLower: Int32! # The lower tick of the position
    tickUpper: Int32! # The upper tick of the position
    amount0: BigInt! # The desired amount of token0
    useFullPrecision: Boolean! # If false, liquidity will be maximized according to what the router can calculate, not what core can theoretically support
  ): Position!

  # Computes a position with the maximum amount of liquidity received for a given amount of token1, assuming an unlimited amount of token0. Always uses full precision.
  createPositionFromAmount1(
    pool: Pool! # The pool for which the position should be created
    tickLower: Int32! # The lower tick of the position
    tickUpper: Int32! # The upper tick of the position
    amount1: BigInt! # The desired amount of token1
  ): Position!

  # Returns the price of token0 at the lower tick
  positionToken0PriceLower(
    position: Position!
  ): Price!

  # Returns the price of token0 at the upper tick
  positionToken0PriceUpper(
    position: Position!
  ): Price!

  # Returns the amount of token0 that this position's liquidity could be burned for at the current pool price
  positionAmount0(
    position: Position!
  ): TokenAmount!

  # Returns the amount of token1 that this position's liquidity could be burned for at the current pool price
  positionAmount1(
    position: Position!
  ): TokenAmount!

  # Returns the minimum amounts that must be sent in order to mint the amount of liquidity held by the position at the current price for the pool
  mintAmounts(
    position: Position!
  ): MintAmounts!

  # Returns the minimum amounts that must be sent in order to safely mint the amount of liquidity held by the position with the given slippage tolerance
  mintAmountsWithSlippage(
    position: Position!
    slippageTolerance: String! # Tolerance of unfavorable slippage from the current price
  ): MintAmounts!

  # Returns the minimum amounts that should be requested in order to safely burn the amount of liquidity held by the position with the given slippage tolerance
  burnAmountsWithSlippage(
    position: Position!
    slippageTolerance: String! # Tolerance of unfavorable slippage from the current price
  ): MintAmounts!

   ## Router

  # Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade
  swapCallParameters(
    trades: [Trade!]! # trades to produce call parameters for
    options: SwapOptions! # options for the call parameters
  ): MethodParameters!

   ## Router Utils: Encode route, SelfPermit, Payments, MultiCall

  # Converts a route to a hex encoded path
  encodeRouteToPath(
    route: Route! # the v3 path to convert to an encoded path
    exactOutput: Boolean! # whether the route should be encoded in reverse, for making exact output swaps
  ): String!

  encodePermit(
    token: Token!
    options: PermitOptions!
  ): String!

  encodeUnwrapWETH9(
    amountMinimum: BigInt!
    recipient: String!
    feeOptions: FeeOptions
  ): String!

  encodeSweepToken(
    token: Token!
    amountMinimum: BigInt!
    recipient: String!
    feeOptions: FeeOptions
  ): String!

  encodeRefundETH: String!

  encodeMulticall(
    calldatas: [String!]!
  ): String!

   ## Staker

  # Returns the calldatas for 'unstakeToken', 'claimReward', and 'stakeToken'.
  # Note:  A `tokenId` can be staked in many programs but to claim rewards and continue the program you must unstake, claim, and then restake.
  collectRewards(
    incentiveKeys: [IncentiveKey!]! # An array of IncentiveKeys that `tokenId` is staked in; claims rewards for each program.
    options: ClaimOptions! # ClaimOptions to specify tokenId, recipient, and amount wanting to collect. Note that you can only specify one amount and one recipient across the various programs if you are collecting from multiple programs at once.
  ): MethodParameters!

  # Returns calldata for unstaking, claiming, and withdrawing.
  withdrawToken(
    incentiveKeys: [IncentiveKey!]! # A list of incentiveKeys to unstake from. Should include all incentiveKeys (unique staking programs) that `options.tokenId` is staked in.
    options: FullWithdrawOptions! # Options for producing claim calldata and withdraw calldata. Can't withdraw without unstaking all programs for `tokenId`.
  ): MethodParameters!

  # Returns an encoded IncentiveKey as a string
  encodeDeposit(
    incentiveKeys: [IncentiveKey!]! # An array of IncentiveKeys to be encoded and used in the data parameter in `safeTransferFrom`
  ): String!

   ## Quoter

  # Produces the on-chain method name of the appropriate function within QuoterV2, and the relevant hex encoded parameters.
  quoteCallParameters(
    route: Route! # The swap route, a list of pools through which a swap can occur
    amount: TokenAmount! # The amount of the quote, either an amount in, or an amount out
    tradeType: TradeType! # The trade type, either exact input or exact output
    options: QuoteOptions
  ): MethodParameters!

  ## NonfungiblePositionManager

  createCallParametersNFPM(
    pool: Pool!
  ): MethodParameters!

  addCallParametersNFPM(
    position: Position!
    options: AddLiquidityOptions!
  ): MethodParameters!

  collectCallParametersNFPM(
    options: CollectOptions!
  ): MethodParameters!

  # Produces the calldata for completely or partially exiting a position
  removeCallParametersNFPM(
    position: Position! # The position to exit
    options: RemoveLiquidityOptions! # Additional information necessary for generating the calldata
  ): MethodParameters!

  safeTransferFromParametersNFPM(
    options: SafeTransferOptions!
  ): MethodParameters!

  ## Utils

  # Converts a big int to a hex string
  toHex(
    value: BigInt!
  ): String!

  # Computes a pool address
  computePoolAddress(
    factoryAddress: String! # The Uniswap V3 factory address
    tokenA: Token! # The first token of the pool, irrespective of sort order
    tokenB: Token! # The second token of the pool, irrespective of sort order
    fee: FeeAmount! # The fee tier of the pool
    initCodeHashManualOverride: String # Override the init code hash used to compute the pool address if necessary
  ): String!

  # Returns the sqrt ratio as a Q64.96 corresponding to a given ratio of amount1 and amount0
  encodeSqrtRatioX96(
    amount1: BigInt! # The numerator amount i.e., the amount of token1
    amount0: BigInt! # The denominator amount i.e., the amount of token0
  ): BigInt!

  # fullMath
  mulDivRoundingUp(
    a: BigInt!
    b: BigInt!
    denominator: BigInt!
  ): BigInt!

  # liquidityMath
  addDelta(
    x: BigInt!
    y: BigInt!
  ): BigInt!

  # Computes the maximum amount of liquidity received for a given amount of token0, token1, and the prices at the tick boundaries.
  maxLiquidityForAmounts(
    sqrtRatioCurrentX96: BigInt! # the current price
    sqrtRatioAX96: BigInt! # price at lower boundary
    sqrtRatioBX96: BigInt! # price at upper boundary
    amount0: BigInt! # token0 amount
    amount1: BigInt! # token1 amount
    useFullPrecision: Boolean! # if false, liquidity will be maximized according to what the router can calculate, not what core can theoretically support
  ): BigInt!

  # Returns the most significant bit of a positive integer, starting with first bit = 0
  mostSignificantBit(
    x: BigInt!
  ): UInt32!

  # Returns the closest tick that is nearest a given tick and usable for the given tick spacing
  nearestUsableTick(
    tick: Int32! # the target tick
    tickSpacing: Int32! # the spacing of the pool
  ): Int32!

  # Returns a price object corresponding to the input tick and the base/quote token. Inputs must be tokens because the address order is used to interpret the price represented by the tick.
  tickToPrice(
    baseToken: Token! # the base token of the price
    quoteToken: Token! # the quote token of the price
    tick: Int32! # the tick for which to return the price
  ): Price!

  # Returns the first tick for which the given price is greater than or equal to the tick price.
  priceToClosestTick(
    price: Price! # price for which to return the closest tick that represents a price less than or equal to the input price, i.e. the price of the returned tick is less than or equal to the input price. Note that a string price is not used as input here, so the "price" property of the Price type can have any value without affecting the results.
  ): Int32!

  # sqrtPriceMath
  getAmount0Delta(
    sqrtRatioAX96: BigInt!
    sqrtRatioBX96: BigInt!
    liquidity: BigInt!
    roundUp: Boolean!
  ): BigInt!

  # sqrtPriceMath
  getAmount1Delta(
    sqrtRatioAX96: BigInt!
    sqrtRatioBX96: BigInt!
    liquidity: BigInt!
    roundUp: Boolean!
  ): BigInt!

  # sqrtPriceMath
  getNextSqrtPriceFromInput(
    sqrtPX96: BigInt!
    liquidity: BigInt!
    amountIn: BigInt!
    zeroForOne: Boolean!
  ): BigInt!

  # sqrtPriceMath
  getNextSqrtPriceFromOutput(
    sqrtPX96: BigInt!
    liquidity: BigInt!
    amountOut: BigInt!
    zeroForOne: Boolean!
  ): BigInt!

  # validates a tick list
  validateTickList(
    ticks: [Tick!]!
    tickSpacing: Int32!
  ): Boolean!

  # TickList
  tickIsBelowSmallest(
    ticks: [Tick!]!
    tick: Int32!
  ): Boolean!

  # TickList
  tickIsAtOrAboveLargest(
    ticks: [Tick!]!
    tick: Int32!
  ): Boolean!

  # TickList
  nextInitializedTick(
    ticks: [Tick!]!
    tick: Int32!
    lte: Boolean!
  ): Tick!

  # Returns true if a tick list is sorted by tick index
  tickListIsSorted(
    ticks: [Tick!]! # The tick list
  ): Boolean!

  # Returns the sqrt ratio as a Q64.96 for the given tick. The sqrt ratio is computed as sqrt(1.0001)^tick
  getSqrtRatioAtTick(
    tick: Int32! # the tick for which to compute the sqrt ratio
  ): BigInt!

  # Returns the tick corresponding to a given sqrt ratio, s.t. #getSqrtRatioAtTick(tick) <= sqrtRatioX96 and #getSqrtRatioAtTick(tick + 1) > sqrtRatioX96
  getTickAtSqrtRatio(
    sqrtRatioX96: BigInt! # the sqrt ratio as a Q64.96 for which to compute the tick
  ): Int32!

  ##  Fetch

  # returns token object constructed from on-chain token contract
  fetchToken(
    address: String! # the Ethereum address of token's ERC20 contract
    chainId: ChainId! # the id of the chain to be queried
  ): Token!

  # returns pool object constructed from on-chain pool contract
  fetchPoolFromTokens(
    tokenA: Token! # a token in the pool
    tokenB: Token! # the other token in the pool
    fee: FeeAmount! # the pool's fee amount
    fetchTicks: Boolean! # if true, the full list of pool ticks will be fetched
  ): Pool!

  # returns pool object constructed from on-chain pool contract
  fetchPoolFromAddress(
    address: String! # the Ethereum address of the pool contract
    chainId: ChainId! # the id of the chain to be queried
    fetchTicks: Boolean! # if true, the full list of pool ticks will be fetched
  ): Pool!

  # returns array of ticks from on-chain pool contract at given address
  fetchTickList(
    address: String! # the Ethereum address of the pool contract
    chainId: ChainId! # the id of the chain to be queried
  ): [Tick!]!

  ##  Enum Utils

  feeAmountToTickSpacing(
    feeAmount: FeeAmount!
  ): Int32!

  getFeeAmount(
    feeAmount: FeeAmount!
  ): UInt32!

  getPermitV(
    permitV: PermitV!
  ): Int32!

  ##  constants

  FACTORY_ADDRESS: String!

  POOL_INIT_CODE_HASH: String!

  POOL_INIT_CODE_HASH_OPTIMISM: String!

  # historical artifact due to small compiler mismatch
  POOL_INIT_CODE_HASH_OPTIMISM_KOVAN: String!

  MIN_TICK: Int32!

  MAX_TICK: Int32!

  MIN_SQRT_RATIO: BigInt!

  MAX_SQRT_RATIO: BigInt!


}
