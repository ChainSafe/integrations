#import { StaticTxResult } into Ethereum from "w3://ens/ethereum.web3api.eth"
#import { ChainId, TradeType, Currency, Token, TokenAmount, Tick, TickListDataProvider, Pool, FeeAmount, Route, Trade, BestTradeOptions, Position, PermitOptions, FeeOptions, SwapOptions, MethodParameters, GasOptions } from "../common/schema.graphql"

enum Rounding {
  ROUND_DOWN
  ROUND_HALF_UP
  ROUND_UP
}

# Return value of nextInitializedTickWithinOneWord(...)
type NextTickResult {
  index: UInt32!
  found: Boolean!
}

# Return value of getPoolInputAmount(...) and getPoolOutputAmount(...)
type PoolChangeResult {
  tokenAmount: TokenAmount!
  pool: Pool!
}

# Input used to create a trade
type TradeRoute {
  route: Route! # The route of the trade
  amount: TokenAmount! # The amount being passed in or out, depending on the trade type
}

# Input used to create an unchecked trade
type UncheckedTradeRoute {
  route: Route! # The route of the trade
  inputAmount: TokenAmount! # The amount being passed in
  outputAmount: TokenAmount! # The amount returned by the trade when executed
}

# Pool state after swap execution; Return value of simulateSwap(...)
type SimulatedSwapResult {
  amountCalculated: BigInt!
  sqrtRatioX96: BigInt!
  liquidity: BigInt!
  tickCurrent: UInt32!
}

# Return value of computeSwapStep(...), a utility function
type SwapStepResult {
  sqrtRatioNextX96: BigInt!
  amountIn: BigInt!
  amountOut: BigInt!
  feeAmount: BigInt!
}

# Represents a unique staking program.
type IncentiveKey {
  rewardToken: Token! # The token rewarded for participating in the staking program.
  pool: Pool! # The pool that the staked positions must provide in.
  startTime: BigInt! # The time when the incentive program begins.
  endTime: BigInt! # The time that the incentive program ends.
  refundee: String! #  The address which receives any remaining reward tokens at `endTime`.
}

# Options to specify when claiming rewards.
type ClaimOptions {
  tokenId: BigInt! # The id of the NFT
  recipient: String! # Address to send rewards to.
  amount: BigInt # The amount of `rewardToken` to claim. 0 claims all.
}

type FullWithdrawOptions implements ClaimOptions {
  owner: String! # Set when withdrawing. The position will be sent to `owner` on withdraw.
  data: String #  Set when withdrawing. `data` is passed to `safeTransferFrom` when transferring the position from contract back to owner.
}

# Optional arguments to send to the quoter.
type QuoteOptions {
  sqrtPriceLimitX96: BigInt # The optional price limit for the trade.
}

# Options for producing the calldata to add liquidity.
type CommonAddLiquidityOptions {
  slippageTolerance: String! # How much the pool price is allowed to move.
  deadline: BigInt! # When the transaction expires, in epoch seconds.
  useNative: Token # Whether to spend ether. If true, one of the pool tokens must be WETH, by default false
  token0Permit: PermitOptions # The optional permit parameters for spending token0
  token1Permit: PermitOptions # The optional permit parameters for spending token1
}

#type MintOptions implements CommonAddLiquidityOptions {
#  recipient: String! # The account that should receive the minted NFT.
#  createPool: Boolean # Creates pool if not initialized before mint.
#}
#
#type IncreaseOptions implements CommonAddLiquidityOptions {
#  tokenId: BigInt! # Indicates the ID of the position to increase liquidity for.
#}
#
#union AddLiquidityOptions = MintOptions | IncreaseOptions
# TODO: Return to use of union type once union type support is merged
type AddLiquidityOptions implements CommonAddLiquidityOptions {
  recipient: String # The account that should receive the minted NFT.
  createPool: Boolean # Creates pool if not initialized before mint.
  tokenId: BigInt # Indicates the ID of the position to increase liquidity for.
}

type SafeTransferOptions {
  sender: String! # The account sending the NFT.
  recipient: String! # The account that should receive the NFT.
  tokenId: BigInt! # The id of the token being sent.
  data: String # The optional parameter that passes data to the `onERC721Received` call for the staker
}

type CollectOptions {
  tokenId: BigInt! # Indicates the ID of the position to collect for.
  expectedCurrencyOwed0: TokenAmount! # Expected value of tokensOwed0, including as-of-yet-unaccounted-for fees/liquidity value to be burned
  expectedCurrencyOwed1: TokenAmount! # Expected value of tokensOwed1, including as-of-yet-unaccounted-for fees/liquidity value to be burned
  recipient: String! # The account that should receive the tokens.
}

type NFTPermitOptions {
  v: PermitV!
  r: String!
  s: String!
  deadline: BigInt!
  spender: String!
}

# Options for producing the calldata to exit a position.
type RemoveLiquidityOptions {
  tokenId: BigInt! # The ID of the token to exit
  liquidityPercentage: String! # The percentage of position liquidity to exit.
  slippageTolerance: String! # How much the pool price is allowed to move.
  deadline: BigInt! # When the transaction expires, in epoch seconds.
  burnToken: Boolean # Whether the NFT should be burned if the entire position is being exited, by default false.
  permit: NFTPermitOptions # The optional permit of the token ID being exited, in case the exit transaction is being sent by an account that does not own the NFT
  collectOptions: CollectOptions! # Parameters to be passed on to collect
}

type Query {

  ## Token

  currencyEquals(
    currencyA: Currency!
    currencyB: Currency!
  ): Boolean!

  tokenEquals(
    tokenA: Token!
    tokenB: Token!
  ): Boolean!

  tokenAmountEquals(
    tokenAmountA: TokenAmount!
    tokenAmountB: TokenAmount!
  ): Boolean!

  tokenSortsBefore(
    tokenA: Token!
    tokenB: Token!
  ): Boolean!

  ## TickDataProvider

  # constructs and validates TickListDataProvider
  createTickListDataProvider(
    ticks: [Tick!]!
    tickSpacing: UInt32!
  ): TickListDataProvider!

  # returns tick at requested index
  getTick(
    tickIndex: UInt32!
    tickDataProvider: TickListDataProvider!
  ): Tick!

  # returns next initialized tick, or max or min tick. Returns true if a tick is found at index
  nextInitializedTickWithinOneWord(
    tick: UInt32!
    lte: Boolean!
    tickSpacing: UInt32!
    tickDataProvider: TickListDataProvider!
  ): NextTickResult!

  ## Pool

  # constructs and validates pool
  createPool(
    tokenA: Token!
    tokenB: Token!
    fee: FeeAmount!
    sqrtRatioX96: BigInt!
    liquidity: BigInt!
    tickCurrent: UInt32!
    ticks: TickListDataProvider!
  ): Pool!

  getPoolAddress(
    tokenA: Token!
    tokenB: Token!
    fee: FeeAmount!
    initCodeHashManualOverride: String
  ): String!

  # Returns true if the token is either token0 or token1
  poolInvolvesToken(
    token: Token! # The token to check
    pool: Pool!
  ): Boolean!

  # Returns the current mid price of the pool in terms of token0, i.e. the ratio of token1 over token0
  poolToken0Price(
    pool: Pool!
  ): String!

  # Returns the current mid price of the pool in terms of token1, i.e. the ratio of token0 over token1
  poolToken1Price(
    pool: Pool!
  ): String!

  # Return the price of the given token in terms of the other token in the pool.
  poolPriceOf(
    token: Token! # The token to return price of
    pool: Pool!
  ): String!

  # Returns the chain ID of the tokens in the pool.
  poolChainId(
    pool: Pool!
  ): ChainId!

  # Given an input amount of a token, return the computed output amount, and a pool with state updated after the trade
  getPoolOutputAmount(
    inputAmount: TokenAmount! # The input amount for which to quote the output amount
    sqrtPriceLimitX96: BigInt # The Q64.96 sqrt price limit
  ): PoolChangeResult!

  # Given a desired output amount of a token, return the computed input amount and a pool with state updated after the trade
  getPoolInputAmount(
    outputAmount: TokenAmount! # The output amount for which to quote the input amount
    sqrtPriceLimitX96: BigInt # The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap.
  ): PoolChangeResult!

  # Simulations execution of a swap and returns next pool state
  simulateSwap(
    zeroForOne: Boolean! # Whether the amount in is token0 or token1
    amountSpecified: BigInt! # The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
    sqrtPriceLimitX96: BigInt # The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this value after the swap. If one for zero, the price cannot be greater than this value after the swap.
    pool: Pool! # The pool on which to execute the swap
  ): SimulatedSwapResult!

  getPoolTickSpacing(
    pool: Pool!
  ): UInt32!

  ## Route

  # Constructs and validates route
  createRoute(
    pools: [Pool!]!
    input: Token!
    output: Token
  ): Route!

  # Returns the chain id of the tokens in the route
  routeChainId(
    route: Route!
  ): ChainId!

  #  Returns the mid price of the route
  routeMidPrice(
    route: Route!
  ): String!

  ## Trade

  # Constructs an exact in trade with the given amount in and route
  createTradeExactIn(
    route: TradeRoute! # the route of the exact in trade and the amount being passed in
  ): Trade!

  # Constructs an exact out trade with the given amount out and route
  createTradeExactOut(
    route: TradeRoute! # the route of the exact out trade and the amount returned
  ): Trade!

  # Constructs a trade by simulating swaps through the given route
  createTradeFromRoute(
    route: TradeRoute!  # the route to swap through and the amount specified, either input or output, depending on the trade type
    tradeType: TradeType! # whether the trade is an exact input or exact output swap
  ): Trade!

  createTradeFromRoutes(
    routes: [TradeRoute!]! # the routes to swap through and how much of the amount should be routed through each
    tradeType: TradeType! # whether the trade is an exact input or exact output swap
  ): Trade!

  # Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade elsewhere and do not have any tick data
  createUncheckedTrade(
    route: UncheckedTradeRoute! # the route to swap through, the amount being passed in, and the amount returned when the trade is executed
    tradeType: TradeType! # the type of the trade, either exact in or exact out
  ): Trade!

  # Creates a trade without computing the result of swapping through the routes. Useful when you have simulated the trade elsewhere and do not have any tick data
  createUncheckedTradeWithMultipleRoutes(
    routes: [UncheckedTradeRoute!]! # the routes to swap through, the amounts being passed in, and the amounts returned when the trade is executed
    tradeType: TradeType! # the type of the trade, either exact in or exact out
  ): Trade!

  # The price expressed in terms of output amount/input amount.
  tradeExecutionPrice(
    trade: Trade!
  ): String!

  # Returns the percent difference between the route's mid price and the price impact
  tradePriceImpact(
    trade: Trade!
  ): String!

  # Get the minimum amount that must be received from this trade for the given slippage tolerance
  tradeMinimumAmountOut(
    slippageTolerance: String! # The tolerance of unfavorable slippage from the execution price of this trade
    trade: Trade!
  ): TokenAmount!

  # Get the maximum amount in that can be spent via this trade for the given slippage tolerance
  tradeMaximumAmountIn(
    slippageTolerance: String! # The tolerance of unfavorable slippage from the execution price of this trade
    trade: Trade!
  ): TokenAmount!

  # Return the execution price after accounting for slippage tolerance
  tradeWorstExecutionPrice(
    slippageTolerance: String! # the allowed tolerated slippage
    trade: Trade!
  ): String!

  """
  Given a list of pools, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token
  amount to an output token, making at most `maxHops` hops.
  Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting
  the amount in among multiple routes.
  """
  bestTradeExactIn(
    pools: [Pool!]! # the pools to consider in finding the best trade
    amountIn: TokenAmount! # exact amount of input currency to spend
    tokenOut: Token! # the desired currency out
    options: BestTradeOptions
  ): [Trade!]!

  """
  similar to bestTradeExactIn(...) but instead targets a fixed output amount
  given a list of pools, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token
  to an output token amount, making at most `maxHops` hops
  note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting
  the amount in among multiple routes.
  """
  bestTradeExactOut(
    pools: [Pool!]! # the pools to consider in finding the best trade
    tokenIn: Token! # the currency to spend
    amountOut: TokenAmount! # the desired currency amount out
    options: BestTradeOptions
  ): [Trade!]!

  ## Position

  # Constructs and validates a position for a given pool with the given liquidity
  createPosition(
    pool: Pool!
    tickLower: UInt32!
    tickUpper: UInt32!
    liquidity: BigInt!
  ): Position!

  # Computes the maximum amount of liquidity received for a given amount of token0, token1, and the prices at the tick boundaries.
  createPositionFromAmounts(
    pool: Pool! # The pool for which the position should be created
    tickLower: UInt32! # The lower tick of the position
    tickUpper: UInt32! # The upper tick of the position
    amount0: BigInt! # token0 amount
    amount1: BigInt! # token1 amount
    useFullPrecision: Boolean! # If false, liquidity will be maximized according to what the router can calculate, not what core can theoretically support
  ): Position!

  # Computes a position with the maximum amount of liquidity received for a given amount of token0, assuming an unlimited amount of token1
  createPositionFromAmount0(
    pool: Pool! # The pool for which the position should be created
    tickLower: UInt32! # The lower tick of the position
    tickUpper: UInt32! # The upper tick of the position
    amount0: BigInt! # The desired amount of token0
    useFullPrecision: Boolean! # If false, liquidity will be maximized according to what the router can calculate, not what core can theoretically support
  ): Position!

  # Computes a position with the maximum amount of liquidity received for a given amount of token1, assuming an unlimited amount of token0
  createPositionFromAmount1(
    pool: Pool! # The pool for which the position should be created
    tickLower: UInt32! # The lower tick of the position
    tickUpper: UInt32! # The upper tick of the position
    amount1: BigInt! # The desired amount of token1
    useFullPrecision: Boolean! # If false, liquidity will be maximized according to what the router can calculate, not what core can theoretically support
  ): Position!

  # Returns the price of token0 at the lower tick
  positionToken0PriceLower(
    position: Position!
  ): String!

  # Returns the price of token0 at the upper tick
  positionToken0PriceUpper(
    position: Position!
  ): String!

  # Returns the amount of token0 that this position's liquidity could be burned for at the current pool price
  positionAmount0(
    position: Position!
  ): TokenAmount!

  # Returns the amount of token1 that this position's liquidity could be burned for at the current pool price
  positionAmount1(
    position: Position!
  ): TokenAmount!

  # Returns the minimum amounts that must be sent in order to safely mint the amount of liquidity held by the position with the given slippage tolerance
  mintAmountsWithSlippage(
    slippageTolerance: String! # Tolerance of unfavorable slippage from the current price
    position: Position!
  ): MintAmounts!

  # Returns the minimum amounts that should be requested in order to safely burn the amount of liquidity held by the position with the given slippage tolerance
  burnAmountsWithSlippage(
    slippageTolerance: String! # Tolerance of unfavorable slippage from the current price
    position: Position!
  ): MintAmounts!

  # Returns the minimum amounts that must be sent in order to mint the amount of liquidity held by the position at the current price for the pool
  mintAmounts(
    position: Position!
  ): MintAmounts!

  ## Router

  # Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.
  swapCallParameters(
    trades: [Trade!]! # trade to produce call parameters for
    options: SwapOptions! # options for the call parameters
  ): MethodParameters!

  estimateGas(
    parameters: MethodParameters!
    chainId: ChainId
  ): BigInt!

  # TODO: why did i drop this function before?
  execCallStatic(
    parameters: MethodParameters!
    chainId: ChainId!
    gasOptions: GasOptions!
  ): Ethereum_StaticTxResult!

  ## MultiCall

  encodeMulticall(
    calldatas: [String!]!
  ): String!

  ## SelfPermit

  encodePermit(
    token: Token!
    options: PermitOptions!
  ): String!

  ## Payments

  encodeUnwrapWETH9(
    amountMinimum: BigInt!
    recipient: String!
    feeOptions: FeeOptions
  ): String!

  encodeSweepToken(
    token: Token!
    amountMinimum: BigInt!
    recipient: String!
    feeOptions: FeeOptions
  ): String!

  encodeRefundETH: String!

  ## Staker

  # Returns the calldatas for 'unstakeToken', 'claimReward', and 'stakeToken'.
  # Note:  A `tokenId` can be staked in many programs but to claim rewards and continue the program you must unstake, claim, and then restake.
  collectRewards(
    incentiveKeys: [IncentiveKey!]! # An IncentiveKey or array of IncentiveKeys that `tokenId` is staked in. Input an array of IncentiveKeys to claim rewards for each program.
    options: ClaimOptions! # ClaimOptions to specify tokenId, recipient, and amount wanting to collect. Note that you can only specify one amount and one recipient across the various programs if you are collecting from multiple programs at once.
  ): MethodParameters!

  # Returns calldata for unstaking, claiming, and withdrawing.
  withdrawToken(
    incentiveKeys: [IncentiveKey!]! # A list of incentiveKeys to unstake from. Should include all incentiveKeys (unique staking programs) that `options.tokenId` is staked in.
    withdrawOptions: FullWithdrawOptions! # Options for producing claim calldata and withdraw calldata. Can't withdraw without unstaking all programs for `tokenId`.
  ): MethodParameters!

  ## Quoter

  # Produces the on-chain method name of the appropriate function within QuoterV2, and the relevant hex encoded parameters.
  quoteCallParameters(
    route: Route! # The swap route, a list of pools through which a swap can occur
    amount: TokenAmount! # The amount of the quote, either an amount in, or an amount out
    tradeType: TradeType! # The trade type, either exact input or exact output
    options: QuoteOptions
  ): MethodParameters!

  ## NonfungiblePositionManager

  createCallParametersNFPM(
    pool: Pool!
  ): MethodParameters!

  addCallParametersNFPM(
    position: Position!
    options: AddLiquidityOptions!
  ): MethodParameters!

  collectCallParametersNFPM(
    options: CollectOptions!
  ): MethodParameters!

  # Produces the calldata for completely or partially exiting a position
  removeCallParameters(
    position: Position! # The position to exit
    options: RemoveLiquidityOptions! # Additional information necessary for generating the calldata
  ): MethodParameters!

  safeTransferFromParameters(
    options: SafeTransferOptions!
  ): MethodParameters!

  ## Utils

  # Converts a big int to a hex string
  toHex(
    bigint: BigInt!
  ): String!

  computePoolAddress(
    tokenA: Token!
    tokenB: Token!
    fee: FeeAmount!
    initCodeHashManualOverride: String
    factoryAddress: String!
  ): String!

  # Converts a route to a hex encoded path
  encodeRouteToPath(
    route: Route! # the v3 path to convert to an encoded path
    exactOutput: Boolean! # whether the route should be encoded in reverse, for making exact output swaps
  ): String!

  # Returns the sqrt ratio as a Q64.96 corresponding to a given ratio of amount1 and amount0
  encodeSqrtRatioX96(
    amount1: BigInt! # The numerator amount i.e., the amount of token1
    amount0: BigInt! # The denominator amount i.e., the amount of token0
  ): BigInt!

  # fullMath
  mulDivRoundingUp(
    a: BigInt!
    b: BigInt!
    denominator: BigInt!
  ): BigInt!

  # liquidityMath
  addDelta(
    x: BigInt!
    y: BigInt!
  ): BigInt!

  # Computes the maximum amount of liquidity received for a given amount of token0, token1, and the prices at the tick boundaries.
  maxLiquidityForAmounts(
    sqrtRatioCurrentX96: BigInt! # the current price
    sqrtRatioAX96: BigInt! # price at lower boundary
    sqrtRatioBX96: BigInt! # price at upper boundary
    amount0: BigInt! # token0 amount
    amount1: BigInt! # token1 amount
    useFullPrecision: Boolean! # if false, liquidity will be maximized according to what the router can calculate, not what core can theoretically support
  ): BigInt!

  # mostSignificantBit
  mostSignificantBit(
    x: BigInt!
  ): UInt32

  # Returns the closest tick that is nearest a given tick and usable for the given tick spacing
  nearestUsableTick(
    tick: UInt32! # the target tick
    tickSpacing: UInt32! # the spacing of the pool
  ): UInt32!

  # Returns a price object corresponding to the input tick and the base/quote token. Inputs must be tokens because the address order is used to interpret the price represented by the tick
  tickToPrice(
    baseToken: Token! # the base token of the price
    quoteToken: Token! # the quote token of the price
    tick: UInt32! # the tick for which to return the price
  ): String!

  # Returns the first tick for which the given price is greater than or equal to the tick price
  priceToClosestTick(
    price: String! # price for which to return the closest tick that represents a price less than or equal to the input price, i.e. the price of the returned tick is less than or equal to the input price
  ): UInt32!

  # sqrtPriceMath
  getAmount0Delta(
    sqrtRatioAX96: BigInt!
    sqrtRatioBX96: BigInt!
    liquidity: BigInt!
    roundUp: Boolean!
  ): BigInt!

  # sqrtPriceMath
  getAmount1Delta(
    sqrtRatioAX96: BigInt!
    sqrtRatioBX96: BigInt!
    liquidity: BigInt!
    roundUp: Boolean!
  ): BigInt!

  # sqrtPriceMath
  getNextSqrtPriceFromInput(
    sqrtPX96: BigInt!
    liquidity: BigInt!
    amountIn: BigInt!
    zeroForOne: Boolean!
  ): BigInt!

  # sqrtPriceMath
  getNextSqrtPriceFromOutput(
    sqrtPX96: BigInt!
    liquidity: BigInt!
    amountOut: BigInt!
    zeroForOne: Boolean!
  ): BigInt!

  # swapMath
  computeSwapStep(
    sqrtRatioCurrentX96: BigInt!
    sqrtRatioTargetX96: BigInt!
    liquidity: BigInt!
    amountRemaining: BigInt!
    feePips: FeeAmount!
  ): SwapStepResult!

  # validates a tick list
  validateTickList(
    ticks: [Tick!]!
    tickSpacing: UInt32!
  ): Boolean!

  # TickList
  tickIsBelowSmallest(
    ticks: [Tick!]!
    tick: UInt32!
  ): Boolean!

  # TickList
  tickIsAtOrAboveLargest(
    ticks: [Tick!]!
    tick: UInt32!
  ): Boolean!

  # TickList
  nextInitializedTick(
    ticks: [Tick!]!
    tick: UInt32!
    lte: Boolean!
  ): Tick!

  # Returns the sqrt ratio as a Q64.96 for the given tick. The sqrt ratio is computed as sqrt(1.0001)^tick
  getSqrtRatioAtTick(
    tick: UInt32! # the tick for which to compute the sqrt ratio
  ): BigInt!

  # Returns the tick corresponding to a given sqrt ratio, s.t. #getSqrtRatioAtTick(tick) <= sqrtRatioX96 and #getSqrtRatioAtTick(tick + 1) > sqrtRatioX96
  getTickAtSqrtRatio(
    sqrtRatioX96: BigInt! # the sqrt ratio as a Q64.96 for which to compute the tick
  ): UInt32!

  ##  Fetch

  fetchTokenData(
    chainId: ChainId!
    address: String!
  ): Token!

  fetchPoolData(
    token0: Token!
    token1: Token!
  ): Pool!

  fetchTotalSupply(
    token: Token!
  ): TokenAmount!

  ##  constants

  FACTORY_ADDRESS: String!
  POOL_INIT_CODE_HASH: String!
}
