#import { Mutation, TxResponse } into Ethereum from "w3://ens/ethereum.web3api.eth"
#import { ChainId, Currency, Token, TokenAmount, Route, Trade, TradeType, Pool, FeeAmount, SwapOptions, MethodParameters } from "../common/schema.graphql"

type GasOptions {
  gasPrice: BigInt
  gasLimit: BigInt
}

type Mutation {
  approve(
    token: Token!
    amount: BigInt
    gasOptions: GasOptions
  ): Ethereum_TxResponse!

  execCall(
    parameters: MethodParameters!
    address: String!
    chainId: ChainId!
    gasOptions: GasOptions
  ): Ethereum_TxResponse!

  execSwap(
    trades: [Trade!]!
    swapOptions: SwapOptions!
    gasOptions: GasOptions
  ): Ethereum_TxResponse!

  # Perform on-chain swap using token and fee amount information to find the correct pool
  swap(
    inToken: Token! # input token
    outToken: Token! # output token
    fee: FeeAmount! # fee amount of the pool being used for the swap
    amount: BigInt! # amount being swapped in or out, depending on trade type
    tradeType: TradeType! # type of trade, either exact input with calculated output or vice versa
    swapOptions: SwapOptions! # configuration for the swap
    gasOptions: GasOptions # optional configuration for transaction gas
  ): Ethereum_TxResponse!

  # Perform on-chain swap using pool at provided address; requires ERC20-compliant input and output (i.e. no Ether)
  swapWithPool(
    address: String! # Ethereum address of pool used for swap
    amount: TokenAmount! # token amount being swapped in or out, depending on trade type
    tradeType: TradeType! # type of trade, either exact input with calculated output or vice versa
    swapOptions: SwapOptions! # optional configuration for the swap
    gasOptions: GasOptions # optional configuration for transaction gas
  ): Ethereum_TxResponse!

  deployPool(
    pool: Pool!
    gasOptions: GasOptions
  ): Ethereum_TxResponse!

  deployPoolFromTokens(
    tokenA: Token!
    tokenB: Token!
    fee: FeeAmount!
    gasOptions: GasOptions
  ): Ethereum_TxResponse!
}
