enum ChainId {
  MAINNET
  ROPSTEN
  RINKEBY
  GOERLI
  KOVAN
  OPTIMISM
  OPTIMISM_KOVAN
  ARBITRUM_ONE
  ARBITRUM_ONE_RINKEBY
}

enum FeeAmount {
  LOWEST
  LOW
  MEDIUM
  HIGH
}

enum TradeType {
  EXACT_INPUT
  EXACT_OUTPUT
}

enum PermitV {
  v_0
  v_1
  v_27
  v_28
}

type Token {
  chainId: ChainId!
  address: String!
  currency: Currency!
}

type Currency {
  decimals: UInt8!
  symbol: String
  name: String
}

# Represents Price of a token in terms of another token. When used as a function argument, the 'price' property is ignored.
type Price {
  baseToken: Token! # the base token of the price
  quoteToken: Token! # the quote token of the price
  denominator: BigInt! # amount of base token used to calculate price
  numerator: BigInt! # amount of quote token used to calculate price
  price: String! # a decimal string representation of the price
}

# Represents fraction, typically a percent.
type Fraction {
  numerator: BigInt!
  denominator: BigInt!
  quotient: String! # a decimal string representation of the fraction
}

type TokenAmount {
  token: Token!
  amount: BigInt!
}

type Tick {
  index: Int32!
  liquidityGross: BigInt!
  liquidityNet: BigInt!
}

type Pool {
  token0: Token!
  token1: Token!
  fee: FeeAmount!
  sqrtRatioX96: BigInt!
  liquidity: BigInt!
  tickCurrent: Int32!
  tickDataProvider: [Tick!]!
  token0Price: Price!
  token1Price: Price!
}

type Route {
  pools: [Pool!]!
  path: [Token!]!
  input: Token!
  output: Token!
  midPrice: Price!
}

# Options used when determining the best trade in bestTradeExactIn(...) and bestTradeExactOut(...)
type BestTradeOptions {
  maxNumResults: UInt32 # maximum number of results to return
  maxHops: UInt32 # maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool
}

type TradeSwap {
  route: Route! # The route of the trade
  inputAmount: TokenAmount! # The amount being passed in
  outputAmount: TokenAmount! # The amount returned by the trade when executed
}

type Trade {
  swaps: [TradeSwap!]!
  tradeType: TradeType!
  inputAmount: TokenAmount!
  outputAmount: TokenAmount!
  executionPrice: Price!
  priceImpact: Fraction!
}

type MintAmounts {
  amount0: BigInt!
  amount1: BigInt!
}

type Position {
  pool: Pool!
  tickLower: Int32!
  tickUpper: Int32!
  liquidity: BigInt!
  token0Amount: TokenAmount!
  token1Amount: TokenAmount!
  mintAmounts: MintAmounts!
  token0PriceLower: Price!
  token0PriceUpper: Price!
}

#type StandardPermitArguments {
#  v: PermitV!
#  r: String!
#  s: String!
#  amount: BigInt!
#  deadline: BigInt!
#}
#
#type AllowedPermitArguments {
#  v: PermitV!
#  r: String!
#  s: String!
#  nonce: BigInt!
#  expiry: BigInt!
#}
#
#union PermitOptions = StandardPermitArguments | AllowedPermitArguments
# TODO: Return to use of union type once union type support is merged
type PermitOptions {
  v: PermitV!
  r: String!
  s: String!
  amount: BigInt
  deadline: BigInt
  nonce: BigInt
  expiry: BigInt
}

type FeeOptions {
  fee: String! # The percent of the output that will be taken as a fee.
  recipient: String! # The recipient of the fee.
}

type SwapOptions {
  slippageTolerance: String! # How much the execution price is allowed to move unfavorably from the trade execution price.
  recipient: String! # The account that should receive the output.
  deadline: BigInt! # When the transaction expires, in epoch seconds.
  inputTokenPermit: PermitOptions # The optional permit parameters for spending the input.
  sqrtPriceLimitX96: BigInt # The optional price limit for the trade.
  fee: FeeOptions # Optional information for taking a fee on output.
}

type MethodParameters {
  calldata: String! # The hex encoded calldata to perform the given operation
  value: String! # The amount of ether (wei) to send in hex.
}
